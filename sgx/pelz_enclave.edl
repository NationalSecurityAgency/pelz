enclave {
	from "sgx_tsgxssl.edl" import *;
	from "sgx_pthread.edl" import *;
	from "kmyth_enclave.edl" import *;
        include "aes_keywrap_3394nopad.h"
	include "pelz_request_handler.h"
	include "common_table.h"
	include "key_table.h"
	include "pelz_io.h"
	include "charbuf.h"
        include "util.h"
	trusted {

/**
 * <pre>
 * This function destroys the table specified by type.
 * <pre>
 *
 * @param[in] type The type of table to be destroyed (ex: key_table or server_table)
 *
 * @return OK on success, an error message indicating the type of
 *                    error otherwise.
 */
public TableResponseStatus table_destroy(TableType type);

/**
 * <pre>
 * This function deletes a value in hash table based on location in id.
 * <pre>
 *
 * @param[in] type The table type that the id and value needs to be deleted from
 * @param[in] id.chars Table value identifier 
 * @param[in] id.len The length of the identifier
 *
 * @return OK on success, an error message indicating the type of
 *                    error otherwise.
 */
public TableResponseStatus table_delete(TableType type, charbuf id);

/**
 * <pre>
 * This function to add values into the server hash table.
 * </pre>
 *
 * @param[in] handle The handle value for the cert data location in the kmyth unseal data table
 * @param[in] server_table The server table that the new cert needs to be added to
 * @param[out] server_table The server table with the new added cert
 *
 * @return OK on success, an error message indicating the type of
 *                    error otherwise.
 */
public TableResponseStatus server_table_add(uint64_t handle);

/**
 * <pre>
 * This function initializes a pkey.
 * <pre>
 *
 * @param[in] private_pkey The pointer for pkey to be initialized
 * @param[out] private_pkey The initialized pkey
 *
 * @return OK on success, an error message indicating the type of
 *                    error otherwise.
 */
public TableResponseStatus private_pkey_init(void);

/**
 * <pre>
 * This function frees the pkey.
 * <pre>
 *
 * @param[in] private_pkey The pointer for pkey to be freed
 *
 * @return OK on success, an error message indicating the type of
 *                    error otherwise.
 */
public TableResponseStatus private_pkey_free(void);

/**
 * <pre>
 * This function adds a pkey from unseal table based on handle.
 * </pre>
 *
 * @param[in] handle The handle value for the pkey data location in the kmyth unseal data table
 * @param[in] private_pkey The empty or old pkey
 * @param[out] private_pkey The new pkey
 *
 * @return OK on success, an error message indicating the type of
 *                    error otherwise.
 */
public TableResponseStatus private_pkey_add(uint64_t handle);

/**
 * <pre>
 * This function implements the request handling by looking if pelz already has
 * the key and if not then adding the key to the key table. Along with the
 * key lookup, this function checks the request type then based on the request
 * type it calls the wrap or unwrap functions to return requested key value.
 * <pre>
 *
 * @param[in] request_type the type of the request (encrypt or decrypt)
 * @param[in] key_id       the key_id of the key to be used for the request
 * @param[in] data         the input data
 * @param[out] output      a pointer to a charbuf to hold the output, will
 *                         be created inside the call
 *
 * @return REQUEST_OK on success, an error message indicating the type of
 *                    error otherwise.
 */
public RequestResponseStatus pelz_request_handler(RequestType request_type, charbuf key_id, charbuf data, [out] charbuf* output);
	};
	untrusted {
/**
 * <pre>
 * Load key from location stated by Key ID
 * <pre>
 *
 * @param[in] key_id_len   the length of the key identifier
 * @param[in] key_id       a pointer to the key identifier
 * @param[out] key_len     the length of the loaded key
 * @param[out] key         a pointer to a pointer to the key, will be
 *                         allocated within key_load
 *
 * @return 0 on success, 1 on error
 */
int key_load(size_t key_id_len, [in, size=key_id_len] unsigned char* key_id,
             [out] size_t* key_len, [user_check] unsigned char** key);

/**
 * <pre>
 * Malloc untrusted memory from within the enclave. The result must
 * be checked to ensure it lies outside the enclave by calling
 * sgx_is_outside_enclave(*buf, size);
 * <pre>
 *
 * @param[in]     size the size to allocate (in bytes).
 * @param[in,out] buf  a pointer to a pointer to hold the allocated space
 *
 * @return none
 */
void ocall_malloc(size_t size, [user_check] unsigned char** buf);


/**
 * <pre>
 * Frees untrusted memory from within the enclave. If the length of the
 * buffer is available the caller should check that it is entirely outside
 * enclave memory by calling
 * sgx_is_outside_enclave(ptr, len);
 * <pre>
 *
 * @param[in] ptr the pointer to be freed
 * @param[in] len the length of the buffer pointed to by ptr
 *
 * @return none
 */
void ocall_free([user_check] void* ptr, size_t len);
	};
};	
	
